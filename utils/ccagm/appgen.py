#!/usr/bin/env python
# this relies on pythonpath to be set so that the cca python utilities
# are in it. Thus you don't normally use this file, you use the sh wrapper
# generated by configure.

import sys, os, stat, glob
import re
import traceback
import shutil
from ccaxml2.Index import Index
from ccaxml2.Symbol import Symbol

try:  
    set  
except NameError:  
    from sets import Set as set   # Python 2.3 fallback 

from _debug import DEBUGSTREAM # CHECK: replace with cct._debug later?
from agsplices import splices, drivers

# TODO:
# Create subclasses for various languages: 
#    CGenerate, F90Generate, F77Generate
#
# Assumptions:
#    Class Generate is a base class for creating "guts" code for
#    various languages(C,C++,F90,F77).  The assumption here is that
#    much of the code can share the same member variables and functions.
class Generate:
    def __init__(self, fd, sidlPkg, scannedFiles, lang,bocca):
        self.eofDone = False
        self.lang = lang
        self.bocca = bocca
        self.params = {'active' : False,
           'currComp' : '',
           'currPort' : '',
           'varlist'  : [] }
        self.palette = {'path' : '', 
                        'repository' : '',
                        'linkage' : 'libtool',
                        'connstack'  : [],
                        'compstack'  : [],
                        'requestlist': [],
                        'index' : None,
                        'scanned' : False
                        } # global palette for path, repository, etc..
        self.fd = fd
        self.sidlPkg = sidlPkg
        self.sidlPkgCName = self.colonMangle(sidlPkg)
        self.scannedFiles = scannedFiles
        self.scannedPaths = scannedFiles
        self.cids = {}         # global dictionary for creating unique component ids
        self.cvals = {}
        self.connIds = {}      # global dictionary for creating unique connection ids
        self.connVals = {}
        self.ccds = {}

    def scanPath(self, className, lang):
        # reindex path if not current
        cindex = self.palette['index']
        if not self.palette['scanned']:
            print "SCANNING ", self.palette['path']
            self.palette['scanned'] = True 
            self.palette['index'] = Index()
            cindex = self.palette['index']
            cindex.setpath(self.palette['path'])
            cindex.debug = True
            cindex.scanpath("_depl.xml")
            cindex.printIndex()
            
        # verify that className appears in index
        sym = cindex.getSymbol(className)
        if not sym:
            raise NameError, "Did not find " + className + " in path= "+ self.palette['path']
 

        # verify that binding lang is listed
        # we want to fail early, not at compile
        clib = sym.getClientLib(lang, self.palette['linkage'])
        if clib == 'unsupported':
            raise TypeError, "Language " + lang + " binding of " + className + " with library kind " + self.palette['linkage'] + "is unsupported."

        print "Found" , className , "for" , lang

    def checkEofDone(self):
        if(self.eofDone):
            print >> sys.stderr, ("eof command found in middle of input. "
                                  + "output may be wrong.")
            sys.exit(1)
            
    def startParamSet(self, newComp, newPort, var, val):
        self.params['currComp'] = newComp 
        self.params['currPort'] = newPort
        self.params['varlist'] = [var]
        self.params[var] = val  
      
    def addParam(self, var, val):
        self.params['varlist'].append(var)
        self.params[var] = val
        
    def genCID(self, name):
        ret = ''
        tempVal = 2
        
        if(self.badComponentName(name) != -1):
            name = name + "_" + str(tempVal)
            tempVal = 3
        try:
            val = self.cvals[name]
            self.cvals[name] += 1
            ret = name + "_" + val
            self.cids[name] = ret
        except KeyError:
            ret = name
            self.cvals[name] = tempVal
            self.cids[name] = ret
        return ret

    def genConnID(self, name):
        ret = ''
        try:
            val = self.connVals[name]
            self.connVals[name] += 1
            ret = name + "_" + val
            self.connIds[name] = ret
        except KeyError:
            ret = name
            self.connVals[name] = 2
            self.connIds[name] = ret
        return ret
            
    def flushConfigRequests(self):
        if(self.params['active']):
            self.genConfigRequests()
            self.params['active'] = False
            
            
    # accumulate all the paths with ":" seperator
    def processPath(self, line):
        path='path'
        tokens = line.split()
        if len(tokens) != PATH_ARGC:
            raise 'Parse Error: ' + line
    
        x     = tokens[2]
        value = tokens[1]
        # python equivalent of switch-case. i.e. switch(value) {..cases ..}
        result = {
            'set':     lambda x: x, 
            'append':  lambda x: self.palette[path] + ':' + x, 
            'prepend': lambda x: x + ':' + self.palette[path]
        }[value](x)   
        self.palette[path] = result
        self.palette['scanned'] = False
             
    def processCode(self, line):
        self.flushConfigRequests()
        tokens = line.split()
        codeKeyword = 'code'
        if tokens[0] == codeKeyword:
            code = line.replace(codeKeyword, '', 1).strip()
            code = code.lstrip('{')
            code = code.rstrip('}')
            print >> self.fd['BMDriverBody'], "\t" + code
            
    def processConfigure(self, line):
        tokens = line.split()
        if len(tokens) < CONF_MIN_ARGC:
            raise SyntaxError, 'Parse Error: ' + line
        
        component = tokens[1]
        port = tokens[2]
        var = tokens[3]
    
        if len(tokens) >= CONF_MAX_ARGC:
            args = " ".join(tokens[4:])
        else:
            self.genConfigReads(component, port, var)
            return
    
        if(self.params['active'] == True):
            if(component == self.params['currComp'] and \
               port == self.params['currPort']):
                self.addParam(var, args)
            else:
                self.genConfigRequests()
                self.startParamSet(component, port, var, args)
        else:
            self.params['active'] = True
            self.startParamSet(component, port, var, args) 
            
    def processEof(self):
        print "processEof start"
        if(self.eofDone):
            return
        self.eofDone = True

        # whack the connections user missed in reverse order.
        self.disconnectSlop()
    
        #whack the components user missed in reverse order.
        self.destroySlop()
    
        #generate factory
        self.genFactory()
        print "processEof end"
        
    def processQuit(self):
        self.checkEofDone()
        self.flushConfigRequests()
        print "\n\t// quit\n"
        self.processEof()
           
    def mangle(self, fname):
        fname = re.sub('\.','_',fname)
        fname = re.sub('-', '_',fname)
        fname = re.sub(':', '_', fname)
        return fname
    
    def barMangle(self, cname):
        cname = re.sub('_', '::', cname)
        return cname
    
    def colonMangle(self, cname):
        cname = re.sub('\.', '::', cname)
        return cname
    
    def badComponentName(self, name):
        badNames = "af services dummy pr myself bs data"
        return badNames.find(name)

        
    
        
# Implementation specific to C++ code generation
# Class CppGenerate will inherit from the base class
# Generate the non-language specific code and members variables    
class CppGenerate(Generate):
    
    # processRespository was originally in the base class Generate,
    # but since it deals with parsing the .CCA files, and the latest
    # schema has separate sections based on language now, it was 
    # moved to here to process language specifics.
    def processRepository(self, line):
        tokens = line.split()
        if len(tokens) > REPO_ARGC:
            raise SyntaxError, 'Parse Error: ' + line
        if len(tokens) < REPO_ARGC:
            print "processRepository bailing on", tokens
            return
        print "processRepository handling", tokens

        self.flushConfigRequests()        
        verb = tokens[1]
        className = tokens[2]
        
        self.palette['requestlist'].append(className)  # add this to the  list
                                                 # of requested classes
        try:
            result = {
                'list':            lambda: {}, # Do nothing 
                'get-ports':       lambda: {}, # Do noting, taken care of 
                                          # at link time by user
                'get':             lambda: self.scanPath(className, "cxx"), 
                'get-global':      lambda: self.scanPath(className, "cxx"), 
                'get-lazy':        lambda: self.scanPath(className, "cxx"), 
                'get-lazy-global': lambda: self.scanPath(className, "cxx")
            }[verb]()  # Equivalent of switch, 
                        # KeyError gives default response
        except KeyError:
            raise SyntaxError, 'Parse Error: Found illegal repository verb: ' + verb


    
    def genFactory(self):
        print "CPP genFactory"
        print >> self.fd['PRctor'], ("/* Generated custom factory " 
                                     + "implementation block */")
        print >> self.fd['PRcreateComp'], ("/* Generated custom factory " 
                                           + "implementation block */")
        
        # Is this best way to keep track of things we've seen?
        incfilesseen = {}
        incdirsseen = {}
        
        requiresargs = dict() ; # dictkey = sidl file, dictvalue = list of symbols
        for key in self.palette['requestlist']:
                print "FACTORY code for", key
                cpname = self.colonMangle(key)
                print >> self.fd['PRctor'], ("\taddDescription(\"" + key 
                                             + "\", \"" + key + "\");")
                print >> self.fd['PRcreateComp'], ("\tif (className == \"" 
                                                   + key + "\") {")
                print >> self.fd['PRcreateComp'], "\t\t" + cpname + " x = "
                print >> self.fd['PRcreateComp'], "\t\t\t" + cpname + "::_create();"
                print >> self.fd['PRcreateComp'], "\t\tgov::cca::Component c = x;"
                print >> self.fd['PRcreateComp'], "\t\treturn c;"
                print >> self.fd['PRcreateComp'], "\t}"

        # after all generated, fix sidl relations.
        requiresargs = dict() ; # rkey = sidl file, rvalue = list of symbols
        requiresorphans = []
        for key in self.palette['requestlist']:
            dep = self.palette['index'].findSymbolDependenciesLocations(key,True)
            for pair in dep:
                print "REQUIRES", pair
                tu = pair.split("@")
                if len(tu) > 1:
                    if requiresargs.has_key(tu[1]):
                        requiresargs[tu[1]].append(tu[0])
                    else:
                        requiresargs[tu[1]] = [tu[0]]
                else:
                    if not pair in requiresorphans:
                        requiresorphans.append(pair)
            

        print "NEED external:", requiresargs
        print "NEED unknown external:", requiresorphans
        print "filtering out cca"
        keep = []
        for k in requiresorphans:
            if k.startswith("gov.cca"):
                continue ; # fixme-- should not treat cca spec specially
        doboccaexternal("PrivateRepository", requiresargs, keep, self.bocca)
        
        # cook up lib list, inserting new things found at front. no doubt more pythonic ways exist.
        liblist=[]
        for key in self.palette['requestlist']:
            dep = self.palette['index'].findLinkFlags(key, self.lang, self.palette['linkage'])
            newlist = []
            for r in dep:
                if not r in liblist:
                    newlist.append(r)
            for r in liblist:
                newlist.append(r)
            liblist = newlist

        inclist=[]
        for key in self.palette['requestlist']:
            dep = self.palette['index'].findIncludeDirs(key, self.lang)
            newlist = []
            for r in dep:
                if not r in inclist:
                    newlist.append(r)
            for r in inclist:
                newlist.append(r)
            inclist = newlist

        for i in liblist:
            print >> self.fd['MAKE'], "#LIBS for" , self.palette['linkage'].upper()
            print >> self.fd['MAKE'], "LIBS += " , i
        
        for i in inclist:
            print >> self.fd['MAKE'], "INCLUDES += -I" + i
                        
    # end genFactory (cpp)
                
    def genConfigReads(self, newComp, newPort, var):  
        self.flushConfigRequests()
        print >> self.fd['BMDriverBody'], ("\t// the next function call "
                                           + "returns a string.") 
        print >> self.fd['BMDriverBody'], ("\tgetParameterValue(" 
                                           + self.cids[newComp] + ",")
        print >> self.fd['BMDriverBody'], ("\t\t\"" + newPort + "\", \"" 
                                           + var + "\", services, bs);")
        
    def genConfigRequests(self):

        print >> self.fd['BMDriverBody'], "\t{"
        print >> self.fd['BMDriverBody'], ("\t\t" + self.sidlPkgCName 
                                           + "::StringMap " 
                                           + " data = " + self.sidlPkgCName 
                                           + "::StringMap::_create();")
        for var in self.params['varlist']:
            print >> self.fd['BMDriverBody'], ("\t\tdata.set(\"" + var 
                                               + "\" , " + "\"" 
                                               + self.params[var] + "\");")
        print >> self.fd['BMDriverBody'], ("\t\tsetParameters(\"" 
                                           + self.params['currComp'] + "\",")
        print >> self.fd['BMDriverBody'], ("\t\t\t\"" + self.params['currPort']
                                           + "\" ,") 
        print >> self.fd['BMDriverBody'], ("\t\t\t" 
                                           + self.cids[self.params['currComp']] 
                                           + " , bs, services, data );")
        print >> self.fd['BMDriverBody'], "\t}"        
 
    def processHeader(self, line):
        tokens = line.split()
        hdrKeyword = 'header-cpp'
        hdrAltKeyword = 'header'
        if tokens[0] == hdrKeyword or tokens[0] == hdrAltKeyword:
            hdr = line.replace(hdrKeyword, '', 1).strip()
            hdr = hdr.replace(hdrAltKeyword, '', 1).strip()
            hdr = hdr.lstrip('{')
            hdr = hdr.rstrip('}')
            print >> self.fd['PRincludes'], hdr
                   
    def processGo(self, line):
        tokens = line.split()
        if len(tokens) != GO_ARGC:
            raise SyntaxError, 'Parse Error: ' + line
        component = tokens[1]
        port = tokens[2]
    
        self.flushConfigRequests()
        print >> self.fd['BMDriverBody'], ""
        print >> self.fd['BMDriverBody'], ("\tinvokeGo( \"" + component + "\","
                                   + "\"" + port + "\", " + self.cids[component]
                                   + " , services, bs);")
        
    def processConnect(self, line):
        tokens = line.split()
        if len(tokens) != CONN_ARGC:
            raise SyntaxError, 'Parse Error: ' + line
        u = tokens[1]
        up = tokens[2]
        p = tokens[3]
        pp = tokens[4]
    
        key = u + '_' + up + '_' + p + '_' + pp
        id = self.genConnID(key)
        uid = self.cids[u]
        pid = self.cids[p]
        print >> self.fd['BMDriverBody'], ("\n\tgov::cca::ConnectionID " + id 
                                           + " = ")
        print >> self.fd['BMDriverBody'], ("\t\tbs.connect(" + uid + ", \"" 
                                           + up + "\"," + pid + ", \"" + pp 
                                           + "\");")
        self.palette['connstack'].append(id)
        
    def processDisconnect(self, line):
        tokens = line.split()
        if len(tokens) != DCONN_ARGC:
            raise SyntaxError, 'Parse Error: ' + line
        u = tokens[1]
        up = tokens[2]
        p = tokens[3]
        pp = tokens[4]
                
        self.flushConfigRequests()
        key = u + '_' + up + '_' + p + '_' + pp
        id = self.connIds[key]
        print >> self.fd['BMDriverBody'], "\tbs.disconnect(" + id + ", 0);"
        self.connIds[id] = ''
        
    def processInstantiate(self, line):
        tokens = line.split()
        if len(tokens) != INST_ARGC:
            raise SyntaxError, 'Parse Error: ' + line
    
        cname = tokens[2]
        type = tokens[1]
        self.checkEofDone()
        self.flushConfigRequests()
        id = self.genCID(cname)
        print >> self.fd['BMDriverBody'], "\n\tgov::cca::ComponentID " + id + " = "
        print >> self.fd['BMDriverBody'], ("\t\tbs.createInstance(\"" + id + "\", "
                                   + "\"" + type + "\", dummy);")
        self.palette['compstack'].append(id)
        

        
    def disconnectSlop(self):
        self.flushConfigRequests()
        print >> self.fd['BMDriverBody'], ("\t// Section to clean up " 
                                           + "connections the user didn't "
                                           + "reverse order.")
        newStack = []
        for id in self.palette['connstack']:
            try:
                if(self.connIds[id] != ''):
                    newStack.append(id)
            except:
                pass
            
        for id in newStack:
            print >> self.fd['BMDriverBody'], "\tbs.disconnect(" + id + ", 0);"
            self.connIds[id] = ''
            
    def destroySlop(self):
        self.flushConfigRequests()
        print >> self.fd['BMDriverBody'], ("\t// Section to clean up " 
                                           + "components the user didn't "
                                           + "reverse order.")
        newStack = []
        for id in self.palette['compstack']:
            try:
                if(self.cids[id] != ''):
                    newStack.append(id)
            except:
                pass
            
        for id in newStack:
            print >> self.fd['BMDriverBody'], ("\tbs.destroyInstance(" 
                                               + id + ", 0.0);")
            self.cids[id] = ''
        

# Implementation specific to C code generation
# Class CGenerate will inherit from the base class
# Generate the non-language specific code and members variables 
class CGenerate(Generate):
    def processRepository(self, line):
        #FIXME: Implement c processRepository
        pass

    def genFactory(self):
        print "C genFactory #fixme implement"
        pass
    
    def genConfigReads(self, newComp, newPort, var):
        #FIXME: implement c genConfigReads
        pass
    
    def genConfigRequests(self):
        #FIXME: implement c genConfigRequests
        pass
    
    def processHeader(self, line):
        #FIXME: implement d processHeader
        pass
    
    def processGo(self, line):
        #FIXME: implement c processGo
        pass
    
    def processConnect(self, line):
        #FIXME: implement c processConnect
        pass
    
    def processDisconnect(self, line):
        #FIXME: implement c processDisconnect
        pass
    
    def processInstantiate(self, line):
        #FIXME: implement c processInstantiate
        pass
    
    def processEof(self):
        #FIXME: implement c processEof
        pass
    
    def disconnectSlop(self):
        #FIXME: implement c disconnectSlop
        pass
    
    def destroySlop(self):
        #FIXME: implement c destroySlop
        pass

# Implementation specific to F77 code generation
# Class F77Generate will inherit from the base class
# Generate the non-language specific code and members variables                                
class F77Generate(Generate):
    def processRepository(self, line):
        #FIXME: implement f7 processRepository
        pass

    def genFactory(self):
        #FIXME: implement f7 genFactory
        pass

    def genConfigReads(self, newComp, newPort, var):
        #FIXME: implement f7 genConfigReads
        pass
    
    def genConfigRequests(self):
        #FIXME: implement f7 genConfigRequests
        pass
    
    def processHeader(self, line):
        #FIXME: implement f7 processHeader
        pass
    
    def processGo(self, line):
        #FIXME: implement f7 processGo
        pass
    
    def processConnect(self, line):
        #FIXME: implement f7 processConnect
        pass
    
    def processDisconnect(self, line):
        #FIXME: implement f7 processDisconnect
        pass
    
    def processInstantiate(self, line):
        #FIXME: implement f7 processInstantiate
        pass
    
    def processEof(self):
        #FIXME: implement f7 processEof
        pass
    
    def disconnectSlop(self):
        #FIXME: implement f7 disconnectSlop
        pass
    
    def destroySlop(self):
        #FIXME: implement f7 destroySlop
        pass

# Implementation specific to F90 code generation
# Class F90Generate will inherit from the base class
# Generate the non-language specific code and members variables
class F90Generate(Generate):
    def processRepository(self, line):
        #FIXME: implement f9 processRepository
        pass

    def genFactory(self):
        #FIXME: implement f9 genFactory
        pass
    
    def genConfigReads(self, newComp, newPort, var):
        #FIXME: implement f9 genConfigReads
        pass
    
    def genConfigRequests(self):
        #FIXME: implement f9 genConfigRequests
        pass

    def processHeader(self, line):
        #FIXME: implement f9 processHeader
        pass
    
    def processGo(self, line):
        #FIXME: implement f9 processGo
        pass
    
    def processConnect(self, line):
        #FIXME: implement f9 processConnect
        pass
    
    def processDisconnect(self, line):
        #FIXME: implement f9 processDisconnect
        pass
    
    def processInstantiate(self, line):
        #FIXME: implement f9 processInstantiate
        pass
    
    def processEof(self):
        #FIXME: implement f9 processEof
        pass
    
    def disconnectSlop(self):
        #FIXME: implement  f9 disconnectSlop
        pass
    
    def destroySlop(self):
        #FIXME: implement f9 destroySlop
        pass

DEBUG = 1

# Comment this line to disable debug
#DEBUGSTREAM = sys.stderr 

# Number of argguments to path, repository keywords. 
# example: path append /path/to/lib
PATH_ARGC = 3
REPO_ARGC = 3
INST_ARGC = 3
GO_ARGC = 3
CONN_ARGC = 5
DCONN_ARGC = 5
PARAM_MIN_ARGC = 4
PARAM_MAX_ARGC = 5
CONF_MIN_ARGC = 4
CONF_MAX_ARGC = 5

gFD = {}           # global File descriptor dictionary
gScannedFiles = [] # contains the list of previosly scanned .cca files

# Dictionay of component data. A Component meta-data can be accessed by 
# component name.
# Example: 
#     name       = 'ccafe.PrinterComponent'
#     myMetaData = gComponentList[name]
#     print 'Component binding = ', myMetaData.binding
gComponentDict = {}

#===============================================================================
# Non-core, util, miscellaneous Methods
#===============================================================================
def err(errmsg='', exitcode=1):
    print >> sys.stderr, errmsg
    sys.exit(exitcode)

def usage():    
    ARGSLEN = 7;
    if len(sys.argv) != ARGSLEN:
        print 'USAGE Error: '
        print '\t appgen <language: cxx (or) c f77 f90 python java> <input> ' \
        '<sidlPackage> <output_dir> <boccaProjectName> ccafesidlpath '
        print '\t Broken Example: /home/baallan/cca/build/cca-spec-babel/utils/ccagm/appgen.py cxx testcxx/test.inp mpitest.script.babel testcxx mpitest /home/baallan/cca/build/cca-tools-contractor/def25/install/share/ccafe-0.8.8/ccafe.sidl'

        sys.exit(0)

# 

def doboccaexternal(classname, tab, orphans, bocca):
    """adds requires to classname given from the dictionary given.
The keys are sidl files, the values are symbol(s) in those files.
"""
    command="change class "+ classname
    for sfile,syms in tab.iteritems():
        command += " --requires=" + ",".join(syms)+"@"+sfile
    for sym in orphans:
        command += " --requires="+sym
    dobocca(command,bocca)
 
def doboccaclass(sidlPkg, classname, implements, inputfile, ccafesidl, otherargs,bocca):
    command="create class " + sidlPkg + "." + classname 
    command += " --import-sidl="+sidlPkg+"." + classname +"@"+inputfile
    if len(implements):
        command += " --implements="+implements
    if len(otherargs):
        command += " " + otherargs
    dobocca(command,bocca)

def dobocca(command,bocca):
    """ run bocca with the args given, returning stdout and scrapping stderr """
    arg = bocca + " " + command
    child = os.popen(arg, 'r')
    data = child.read()
    err = child.close()
    if err:
	raise RuntimeError, '%s failed w/ exit code %d' % (arg, err)
    return data

def doboccamerge(pkg, clname, src, kind, lang, bocca):
    """query bocca project for symbol "pkg.clname" and splice src to it."""
    symbol= pkg + "." + clname
    arg=bocca + " whereis -" + kind + " " + symbol
    child = os.popen(arg, 'r')
    data = child.read()
    err = child.close()
    if err:
	raise RuntimeError, '%s failed w/ exit code %d' % (arg, err)
    target = data.strip()
    print "splicing into", target
    
    sout = open(".agimpl", "w+")
    print >> sout, src
    sout.close()
    impltmp = os.path.abspath(".agimpl")

    #flags = "-d" + " -l " +lang 
    flags = " -l " +lang 
    arg=bocca+"-merge " + flags + " --to=" + target + " --from=" + impltmp
    child = os.popen(arg)
    data = child.read()
    err = child.close()
    if err:
	raise RuntimeError, '%s failed w/ exit code %d' % (arg, err)
    print data
    os.remove(".agimpl")
    arg=bocca+" edit -t -" + kind + " " + symbol
    child = os.popen(arg)
    edata = child.read()
    err = child.close()
    return data

def doboccamain(pkg, fname, src, kind, lang, bocca):
    """write fname in BabelMain component directory"""
    symbol= pkg + "." + "BabelMain"
    arg=bocca + " whereis -" + kind + " " + symbol
    child = os.popen(arg, 'r')
    data = child.read()
    err = child.close()
    if err:
	raise RuntimeError, '%s failed w/ exit code %d' % (arg, err)
    target = data.strip()
    targetdir = os.path.dirname(target)
    target = os.path.join(targetdir,fname)
    print "Writing main() to:", target
    
    sout = open(target, "w+")
    print >> sout, src
    sout.close()

    # from here, bocca has no support except hooks to build the main.
    # we have to create and insert the hook stuff in a builderplugin
    # specific way.

    # add target to make.rules.user
    # figure out the link flags in terms of bocca gmake values
    # add vars if needed to make.vars.user

#===============================================================================
# Core Methods
#==============================================================================
# Copy the template files to the output directory given.
def copyTemplateFiles(outdir, sidlPkg, projname, lang, ccafesidl, bocca):

    olddir = os.getcwd()
    newproj=True
    if not os.path.exists(outdir):
        os.makedirs(outdir)
    os.chdir(outdir)
    projdir=os.path.join(outdir, projname)
    if not os.path.exists(projdir):
        dobocca("create project "+projname + " -l"+lang, bocca)
    else:
        newproj=False
    os.chdir(projname)
    if not os.path.exists("BOCCA"):
        raise NameError, "Directory specified for project already exists, but is not a project. Refusing to stomp on it with a new project."

    # need to check for existing sidlPkg.BabelMain in project. error if so.
    symbol= sidlPkg + "." + "BabelMain"
    arg=bocca+ " whereis class " + symbol
    print "Expecting ERROR. If not seen, we have a problem and must quit.", arg
    child = os.popen(arg)
    data = child.read()
    err = child.close()
    if err is None:
        raise RuntimeError, '%s project already has a generated main %s' % (arg, data)

    # need to check for existing config.log in project before configure. skip if so
    if not os.path.exists("config.log"):
        x=os.system("./configure")
        if x != 0:
            raise IOError, "Unable to run configure in " + projdir + ". Quitting."

    print "Running Babel to generate boilerplate. Kinda slow."
    boccaSetupClasses(sidlPkg, ccafesidl, bocca)
    print "Inserting code. Kinda slow and noisy."
    boccaSpliceClasses(sidlPkg, lang, bocca)
    print "Done with boilerplate"


def boccaSetupClasses(sidlPkg, ccafesidl, bocca):
    """create the classes, ready for impl splicing"""
    start=True
    sidldefs=""
    for i in sidlPkg.split("."):
        sidldefs += "package "+i
        if start:
            sidldefs += " version 0.0 "
            start=False
        sidldefs += " { "

    sidldefs +="""
	class StringMap {

		/** return true if key exists in map. */
		bool has(in string key);

		/** return value of key. if key is not defined in the map,
			has side effect of defining the key with the empty
			string value before returning the empty string.
		*/
		string get(in string key);

		/** add or change the value for a key */
		void set(in string key, in string value);

		/** remove the key and its value, if it is there. */
		void erase(in string key);

		/** ugly c++ pointer returned; type in c++
			'std::map<std::string, std::string> *'
		    This pointer will be valid until the underlying
			babel object (which contains the underlying
			c++ object) is destroyed.
		 */
		opaque getUnderlyingStdMap();
	}

	class BabelMain implements-all ccaffeine.BabelMain
	{
		int invokeGo(in string component, in string port, in gov.cca.ComponentID c , in gov.cca.Services services, in gov.cca.ports.BuilderService bs);

	/** This function handles the configuring of 
		parameters when all we know is the
		info available from a ccaffeine script (which hides 
		parameter and port types).
		If component port and config information were 
		ubiquitous at code generation time, this wouldn't be needed.
		@param compName name of the component being configured.
		@param port name of the port being configured.
		@param comp ComponentID of the component being configured.
		@param bs BuilderService controlling the frame.
		@param services Services of the component/driver 
			doing the parameter setting.
		@param values  map of keys and values to assign.
	*/
		void setParameters(in string component, in string port,
				in gov.cca.ComponentID c, 
				in gov.cca.ports.BuilderService bs, 
				in gov.cca.Services services,
				in StringMap sm);

	/** This function returns a stringified version of a parameter value.
	*/
		string getParameterValue(in gov.cca.ComponentID c , in string portName, in string var, in gov.cca.Services services, in gov.cca.ports.BuilderService bs);

	}

	class PrivateRepository implements-all gov.cca.ports.ComponentRepository,
		ccaffeine.ports.ComponentFactory
	{
		// gov.cca.Component createComponentInstanceSimple(in string className);
		// gov.cca.Component createComponentInstance(in string className, in gov.cca.TypeMap props);
		// void destroyComponentInstance(in string className, in gov.cca.Component c);
		void initialize();  //
		void addDescription(in string className, in string classAlias);
	}

	class ComponentClassDescription implements-all gov.cca.ComponentClassDescription
	{
		void initialize(in string className, in string classAlias);
	}
	
	class Exception extends sidl.SIDLException implements-all gov.cca.CCAException 
	{
		void setType(in gov.cca.CCAExceptionType t);
	}
"""
    for i in sidlPkg.split("."):
        sidldefs += "} "
    sout = open(".agsidl", "w+")
    print >> sout, sidldefs
    sout.close()
    sidltmp = os.path.abspath(".agsidl")

    doboccaclass(sidlPkg,"StringMap","", sidltmp, ccafesidl, "", bocca)
    doboccaclass(sidlPkg,"Exception", "gov.cca.CCAException",  sidltmp, ccafesidl, "", bocca)
    doboccaclass(sidlPkg,"ComponentClassDescription", "gov.cca.ComponentClassDescription", sidltmp, ccafesidl, "", bocca)
    # fixme need the --requires of all used components in the final argument
    doboccaclass(sidlPkg,"PrivateRepository", "gov.cca.ports.ComponentRepository,ccaffeine.ports.ComponentFactory@"+ccafesidl, sidltmp, ccafesidl, "--requires=ComponentClassDescription", bocca)
    # requires are symlist@filename with only one file per symlist. for multiple, group syms by file
    doboccaclass(sidlPkg,"BabelMain", "ccaffeine.BabelMain@"+ccafesidl, sidltmp, ccafesidl, "--requires=StringMap,Exception,PrivateRepository --requires=ccaffeine.ports.ComponentFactory@"+ccafesidl, bocca)

    os.remove(".agsidl")

def extensionToKind(ext):
    if ext in ['cxx','f90','c','java','python', 'f77']:
        return "i"
    if ext in ['hxx','h','mod']:
        return "m"
    return "k" ; # make an error elsewhere

def boccaSpliceClasses(sidlPkg, lang, bocca):
    # compute subs for replacents of classname
    dotpkg=sidlPkg
    ubpkg=""
    dcolpkg=""
    x = sidlPkg.split(".")
    j = len(x)
    for i in x:
        j -= 1
        ubpkg += i
        dcolpkg += i
        if j > 0:
            ubpkg +="_"
            dcolpkg +="::"
    # sub into temp space containing only the specific language
    implsrc = dict()
    for i in splices['extensions'][lang]:
        if not i:
            continue
        implsrc[i] = dict()
        kind = extensionToKind(i)
        for (clname, clsrc) in splices[i].iteritems():
            implsrc[i][clname] = clsrc.replace("UBPKG", ubpkg).replace("DCOLPKG",dcolpkg).replace("DOTPKG",dotpkg)
            # splice from string to file.
            doboccamerge(sidlPkg, clname, implsrc[i][clname], kind, lang, bocca) 
    # make the drive in the babelmain directory
    standalonesrc = dict()
    for i in drivers['extensions'][lang]:
        if not i:
            continue
        standalonesrc[i] = dict()
        kind = extensionToKind(i)
        for (dname, dsrc) in drivers[i].iteritems():
            standalonesrc[i][dname] = dsrc.replace("UBPKG", ubpkg).replace("DCOLPKG",dcolpkg).replace("DOTPKG",dotpkg)
            doboccamain(sidlPkg, dname, standalonesrc[i][dname], kind, lang, bocca)
    

# rework this to 
# accumlate the results in strings instead of files
# replace the @@ blocks (which need to be added in cxxfrage) from splices[lang]
# splice with file names fetched by querying bocca

def openFiles(outdir, projname, sidlPkg, bocca):

    print >> DEBUGSTREAM, 'In openFiles():'
    
    srcoutdir = outdir
    ubPkg = sidlPkg.replace(".","_")
    
    # check if this output directory/path exists. If not create it
    if os.path.exists(srcoutdir):
        mode = os.stat(srcoutdir)[stat.ST_MODE]
        if stat.S_ISDIR(mode):
            if not bool(mode & stat.S_IWRITE):
                err('openFiles(): specified output directory name, ' + 
                    srcoutdir + ', is not writable.')
        else:
            err('openFiles(): specified output directory name, ' + 
                srcoutdir + ', is not a directory.')
    else:
        os.makedirs(srcoutdir) # makes all intermediate-level directories (i.e path)
    
    baseName  = os.path.join(srcoutdir, sidlPkg)
    
    try:
        bmfile=dobocca("whereis -i "+sidlPkg+".BabelMain",bocca)
        bmdir=os.path.dirname(bmfile)
        f_BMdriverBody = open(os.path.join(bmdir, ubPkg + '_BabelMain.driverBody.guts.hh'), 'w+')

        prfile=dobocca("whereis -i "+sidlPkg+".PrivateRepository",bocca)
        prdir=os.path.dirname(prfile)
        f_PRctor       = open(os.path.join(prdir, ubPkg+'_PrivateRepository._ctor.guts.hh'), 'w+')
        f_PRcreateComp = open(os.path.join(prdir, ubPkg+'_PrivateRepository.createComponentInstance.guts.hh'), 'w+')
        f_PRincludes   = open(os.path.join(prdir, ubPkg+'_PrivateRepository._includes.guts.hh'), 'w+')
        f_MAKE         = open(os.path.join(prdir, "make.vars.user"), 'a+')

        
        gFD['MAKE']         = f_MAKE
        gFD['BMDriverBody'] = f_BMdriverBody
        gFD['PRctor']       = f_PRctor
        gFD['PRcreateComp'] = f_PRcreateComp
        gFD['PRincludes']   = f_PRincludes
        
    except:
        print >> sys.stderr, 'OpenFiles(): File open failed'
        raise
    
def closeFiles():
    print >> DEBUGSTREAM, 'In closeFiles():'
    try:
        gFD['MAKE'].close()
        gFD['BMDriverBody'].close()
        gFD['PRctor'].close()
        gFD['PRcreateComp'].close()
        gFD['PRincludes'].close()
    except:
        raise
            

        
#===============================================================================
# processHeader's first argument should of the format, header keyword followed
# by actual language specific header
# Format: header-<lang> <language specific header>
#     Example: processHeader("header-cpp #include <iostream>")
#===============================================================================
def processHeader(line, generator):
    generator.processHeader(line)
 
 #===============================================================================
# processCode's first argument should of the format, code keyword followed
# by the actual code
# Format: code <actual code>
#     Example: processCode("code {std::cerr << std::endl; }")
#===============================================================================       
def processCode(line, generator):
    generator.processCode(line)

#===============================================================================
# processRepository's first argument should be of the format, repository keyword 
# followed by a verb(list,get-ports,get,get-global,get-lazy,get-lazy-globa),
# followed by a repository component.  
# Format: repository <verb> <repository component>
#     Example: processRepository("repository get ccafe0.PrinterComponent")
#=============================================================================== 
def processRepository(line, generator):
    generator.processRepository(line)
  
#===============================================================================
# processPath's first argument should be of the format, path keyword 
# followed by a verb(set,append,prepend),followed by a path component.  
# Format: path <verb> <path component>
#     Example: processPath("path append /msrc/proj/cca/lib")
#===============================================================================      
# accumulate all the paths with ":" seperator
def processPath(line, generator):
    generator.processPath(line)
    
#===============================================================================
# processInstantiate's first argument should be of the format, instantiate
# keyword, followed by a ccafe component, followed by a variable name.  
# Format: instantiate <ccafe component> <variable name>
#     Example: processPath("instantiate ccafe0.PrinterComponent p1")
#=============================================================================== 
def processInstantiate(line, generator):
    generator.processInstantiate(line)

#===============================================================================
# processConfigure's first argument should be of the format, configure
# keyword, followed by a ccafe ParameterPort component variable, followed by 
# (TODO: figure out this paramter), followed by a variable name, followed by
# an optional parameter value.    
# Format: parameter <ccafe ParameterPort component> <TODO: what is this?> 
#                     <variable name> [optional param value]
#     Example: processconfigure("configure c1 PP_1 dVar 22.5")
#===============================================================================              
def processConfigure(line, generator):
    generator.processConfigure(line)   
            
# Seems display is a GUI thing we can ignore
def processDisplay(line, generator):
    pass

#===============================================================================
# processConnect's first argument should be of the format, configure
# keyword, followed by a ccafe ParameterPort component variable, followed by 
# (TODO: figure out this paramter), followed by a variable name, followed by
# an optional parameter value.    
# Format: connect <ccafe ParameterPort component> <TODO: what is this?> 
#                     <variable name> [optional param value]
#     Example: processconfigure("configure c1 PP_1 dVar 22.5")
#=============================================================================== 
def processConnect(line, generator):
    generator.processConnect(line)
    
def processDisconnect(line, generator):
    generator.processDisconnect(line)
  
def processGo(line, generator):
    generator.processGo(line)
   
def processEof(line, generator):
    generator.processEof()
    
def processQuit(line, generator):
    generator.processQuit()
             
    
# keyword to function handler mapping
gProcessKeyword = {'header-cpp' : processHeader, 
                   'header-c'   : processHeader,
                   'header-f77' : processHeader, 
                   'header-f90' : processHeader,
                   'header'     : processHeader,
                   'code'       : processCode,
                   'repository' : processRepository,
                   'path'       : processPath,
                   'instantiate': processInstantiate,
                   'create'     : processInstantiate,
                   'param'      : processConfigure,
                   'parameter'  : processConfigure,
                   'configure'  : processConfigure,
                   'config'     : processConfigure,
                   'display'    : processDisplay,
                   'connect'    : processConnect,
                   'disconnect' : processDisconnect,
                   'go'         : processGo,
                   'eof'        : processEof,
                   'quit'       : processQuit
                   }

def verifyKeyword(keyword):
    if not gProcessKeyword.has_key(keyword):
        raise 'Parse Error: Found illegal keyword: ' + keyword
    return 
    

# this is an internal testing entry point, not for public consumption.
# the doc string refers to gen-cca-main, actually.
def appGen(bindir=""):
    """Usage: gen-cca-main [options] inputFile sidlPackage

Required inputs:

inputFile: the name of the ccaffeine batch script or gui log.
sidlPackage: the name of the sidl package in which the generated 
        BabelMain will reside.
	Only one generated main per sidl package is possible because standard
	class names are used for the main and support classes.

Options:
  -h, --help            show this help message and exit
  -l LANG, --language=LANG
                        generate the sidl/babel implementation in LANG.
                        Default is cxx and may someday become C.
  -p PROJNAME, --project=PROJNAME
                        name of generated project given to bocca.
                        Default is Main_<sidlPackage>
  -o OUTDIR, --output-dir=OUTDIR
                        name of directory where bocca project will be created.
                        Default is (.), the current directory.
  -b BOCCAPROG, --with-bocca=BOCCAPROG
                        full path to bocca program.
                        Default is bocca in the path, 
                        then in $CCA_TOOLS_DIR/bin if any, 
                        then the bocca co-installed with this script if any.

Purpose:

Generate a bocca project building a standalone executable based on
a ccaffeine batch script. This has several steps:
	Create the bocca project per the user options or defaults.
	Create the boilerplate classes needed for a cca-ified main.
	Based on the input script, generate a custom BabelMain.driverBody()
	Based on the input script, generate a custom component factory.
	Generate auxiliary inputs to 'make' for the bocca project.
	Compile it all through bocca.
	Link sidlPackage.BabelMain with a generic main 
	that initializes ccaffeine.

Hotline:
	baallan@sandia.gov, help@cca-forum.org
"""

    print >> DEBUGSTREAM, 'In appGen(): Begin'

    lang      = sys.argv[1]
    inputFile = os.path.abspath(sys.argv[2])
    
    # Is this where we should set these?
    sidlPkg = sys.argv[3]
    outdir = os.path.abspath(sys.argv[4])
    projname = sys.argv[5]
    ccafesidl = sys.argv[6]

    # assuming bocca in path
    appGenCore(lang, inputFile, sidlPkg, outdir, projname, ccafesidl, "bocca") 

def appGenCore(lang, inputFile, sidlPkg, outdir, projname, ccafesidl, bocca):
    print "# lang = ", lang
    print "# input= ", inputFile
    print "# sidl pkg for gen'd code = ", sidlPkg
    print "# output directory = ", outdir
    print "# project name (gen'd bocca proj name) = ", projname
    print "# ccaffeine sidl = ", ccafesidl
    print "# bocca = ", bocca

    if not lang in ['c','cxx','f90','python','java']:
        raise NameError, "Language "+lang +" is not supported."

    # copy the template files to the output directory
    copyTemplateFiles(outdir, sidlPkg, projname, lang, ccafesidl, bocca)

    # create "guts" files
    openFiles(outdir, projname, sidlPkg, bocca)

      
    try:
        generator = {
            'cxx':     lambda: CppGenerate(gFD, sidlPkg, gScannedFiles, lang, bocca), 
            'c':       lambda: CGenerate(gFD, sidlPkg, gScannedFiles, lang, bocca),
            'f77':     lambda: F77Generate(gFD, sidlPkg, gScannedFiles, lang, bocca), 
            'f90':     lambda: F90Generate(gFD, sidlPkg, gScannedFiles, lang, bocca)                                       
        }[lang]()  
    except KeyError:
        print "Unrecognized Language: " + lang
        sys.exit(1)   
    
    
    # parse and process the input file
    f_scr = open(inputFile, 'r')
    linenum=0
    alllines = f_scr.readlines()
    alllines.append('eof')
    for line in alllines:
        linenum += 1
        
        line = line.strip()
        
        if line.startswith('#') : continue  # skip comment lines
        if len(line) == 0       : continue  # skip empty lines
        
        # remove "!" (ccaffeine comment) and process the rest as usual
        if line.startswith('!') : line = line[1:].strip() 
        print "PROCESSING ", line
        
        try:
            # identifies and processes the keyword
            tokens = line.split()
            keyword = tokens[0]
            verifyKeyword(keyword)
            gProcessKeyword[keyword](line, generator)
        except:
            print 'Error: Parse error in %s line# %d: %s' % ( inputFile , linenum, line )
            raise
    
    f_scr.close()
    closeFiles()
    print >> DEBUGSTREAM, 'In appGen(): End'


def main():
    usage()
    print sys.version_info
    appGen()
    
if __name__ == '__main__':
    print '#'*20 + ' Bocca Application Generator ' + '#'*20
    main()
    print '#'*20 + ' Bocca Application Generator Done ' + '#'*15

