from xml.dom import minidom, Node
from Symbol import Symbol

###############################################################################

class Walker:
    """Iterate over all a dom tree. Surely there's one of these in the standard
library someday."""
    def startElement(self, node):
        pass
    def walk(self, node):
        for i in node.childNodes:
            self.walk(i)
        self.startElement(node)

###############################################################################

class Walker2:
    """Iterate over all a dom tree statefully. Surely there's one of these in the standard
library someday."""
    def startNode(self, node):
        pass
    def endNode(self, node):
        pass
    def walk(self, node):
        self.startNode(node)
        for i in node.childNodes:
            self.walk(i)
        self.endNode(node)

###############################################################################

class Stripper(Walker):
    """Walker that clears leading/trailing and null whitespace nodes from dom.
This is a private implementation detail of File."""
    def __init__(self):
        self.killlist = []

    def startElement(self, node):
        if node.nodeType == Node.TEXT_NODE:
            node.data = node.data.strip()
            if len(node.data) == 0:
                self.killlist.append((node, node.parentNode))

    def cleanEmpties(self):
        """prunes empty text nodes found generated by carriage returns"""
        for i in self.killlist:
            (node, parent) = i
            parent.removeChild(node)
            node.unlink()

###############################################################################

class PathChecker(Walker2):
    """Walker that prints any undefined paths found in xml text nodes.
Ignores the unsupported path.
Is aware of prefix
"""
    def __init__(self):
        self.currentprefix=None

    def startNode(self, node):
        import os
        if node.nodeType == Node.ELEMENT_NODE:
            name=node.nodeName
            if name and (name == "interfaceDeployment" or 
                         name == "classDeployment" or
                         name == "componentDeployment" or
                         name == "portDeployment"):
                self.currentprefix = node.getAttribute("prefix")
                # print "CURRENT %prefix% is", self.currentprefix
                self.eltname = name

    def endNode(self, node):
        """This relies on the deployment tags not being legal to nest"""
        import os
        if node.nodeType == Node.ELEMENT_NODE:
            name=node.nodeName
            if self.eltname == name:
                self.currentprefix = None
                self.eltname = None
                # print "CURRENT %prefix% is None"

        if node.nodeType == Node.TEXT_NODE:
            x = node.data.strip()
            if len(x) == 0:
                return
            if x == "unsupported":
                return
            if "," in x or x.startswith("gov.cca") or x.startswith("sidl"):
                return
            if x[0] == '%' and self.currentprefix:
                x = x.replace("%prefix%",self.currentprefix)
            if os.path.isdir(x):
                # print "DIR:", x
                return
            if os.path.isfile(x):
                # print "FILE:", x
                return
            print "UNDEFINED PATH:",x
            if x[0] == '%':
                print "UNDEFINED PREFIX IN",x

###############################################################################

class File:
    """Wrapper on dom/file behind it. This should know/use no dom details below
the level of deployment type and perhaps scl. The messy xml bits are managed
by Symbol. Normally this object should be invisible to most applications."""
    def __init__(self,filename, new=None):
        """@param input filename or new filename.
@param new (optional) "new" if a new file to be created.
"""
        if new:
            self.changed = True
            base="""<?xml version="1.0" ?>
<libInfo>
<!-- # generated index. -->
<!--  -->
</libInfo>
"""
            self.dom = minidom.parseString(base)
        else:
            self.dom = minidom.parse(filename)
            self.changed = False
        self.indexed = False
        # whack the prettyprinting from the input so we don't feedback grow.
        stripper = Stripper()
        self.dom.normalize()
        stripper.walk(self.dom)
        stripper.cleanEmpties()

        self.filename = filename
        self.symlist = []

    def pathCheck(self, node):
        if node:
            w = PathChecker()
            w.walk(node)
        else:
            print "Symbol has no xml!"


    def clear(self):
        if self.dom:
            self.dom.unlink()
            self.dom = None

    def setChanged(self):
        self.changed = True

    def setIndexed(self):
        self.indexed = True

    def writeChanges(self):
        if self.changed:
            # print "Updating", self.filename
            self.write(self.filename)
        else:
            # print "Not updating", self.filename
            pass

    def write(self, filename):
        dump = self.dom.toprettyxml(indent="    ")
        wfile = open(filename,"w")
        wfile.write(dump)
        wfile.close()

    def domToSymtab(self, symtab):
        """construct symbols into table given from our dom read from file."""
        d = self.dom
        interfaces = d.getElementsByTagName("interfaceDeployment")
        for i in interfaces:
            s = Symbol(self. filename)
            s.readInterface(i)
            self.addSymtabEntry(symtab, s) 

        classes = d.getElementsByTagName("classDeployment")
        for i in classes:
            s = Symbol(self. filename)
            s.readClass(i)
            self.addSymtabEntry(symtab, s) 

        ports = d.getElementsByTagName("portDeployment")
        for i in ports:
            s = Symbol(self. filename)
            s.readPort(i)
            self.addSymtabEntry(symtab, s) 

        components = d.getElementsByTagName("componentDeployment")
        for i in components:
            s = Symbol(self. filename)
            s.readComponent(i)
            self.addSymtabEntry(symtab, s) 

        self.indexed = True

    def domFromSymbol(self, symbol):
        """Output Symbol information to the file's dom if not already in place.
Symbol does not know its doc root; file does."""
        symbol.domUpdate(self.dom)
        
    def addSymtabEntry(self, symtab, s):
        """private"""
        key = s.getSidlName()
        if symtab.has_key(key):
            print "Ignoring "+ key + " in "+ self.filename + ". Seen previously in " + symtab[key].getFilename()
        else:
            symtab[key] = s
            self.symlist.append(key)

    def getSymNames(self):
        """return list of symbols defined in file"""
        return self.symlist

    def insertSymbol(self, symbol):
        """ tell the file it's owner of the sidl symbol given. no other data created or touched."""
        if not symbol in self.symlist:
            self.symlist.append(symbol)
            self.changed = True
        else:
            raise RuntimeError, "Attempt to insert existing symbol to file " + self.filename
        # should we change self.indexed?

